\ifx\PREAMBLE\undefined
\input{preamble}
\begin{document}
\fi
\chapter{Querying Relational Database}
A \textbf{query} on a set of relations produces a relation as result. We will use a simple college admissions database as example in this chapter. It contains three relations:
\begin{lstlisting}[escapechar=@]
College(_cName_, state, enrollment)
Student(_sID_, sName, GPA, sizeHS@\footnote{sizeHZ means size of the high school the student attended.}@)
Apply(_sID_, _cName_, _major_, decision)
\end{lstlisting}
The key in each relation is underlined.
\section{Relational Algebra}
\subsection{Relation Name Query}
The simplest query is a relation name. For example, the query
\begin{center}
\texttt{Student}
\end{center}
will return a copy of the \texttt{Student} relation. In more complex queries, we will use \textbf{operators} to filter, slice and combine relations.
\subsection{Select Operator}
The \textbf{Select} operator is used to pick out certain rows. It is written as a $\sigma$ with a subscript being the condition of the selection followed by the relation being queried. For example:
\begin{itemize}
\item Students with GPA$>$3.7: $$\mathtt{\sigma_{GPA>3.7}Student}$$
\item Students with GPA$>$3.7 and sizeHS$<$1000: $$\mathtt{\sigma_{GPA>3.7\:\land\: sizeHS<1000}Student}$$
\item Applications to Stanford CS major: $$\mathtt{\sigma_{cName='Stanford'\:\land\: major='CS'}Apply}$$
\end{itemize}
\subsection{Project Operator}
The \textbf{Project} operator picks certain columns. It is written as a $\Pi$ with a subscript being the columns to be picked followed by the relation being queried. For example:
\begin{itemize}
\item ID and decision of all applications: $$\mathtt{\Pi_{sID, decision}Apply}$$
\end{itemize}
If we want to pick both rows and columns, we can simply combine select and project. For example:
\begin{itemize}
\item ID and name of students with GPA$>$3.7:$$\mathtt{\Pi_{sID,sName}\left(\sigma_{GPA>3.7}Student\right)}$$
\end{itemize}
In relation algebra, duplicates in a query result are always eliminated. It is guaranteed that the same tuple does not appear more than once. This is different from SQL, in which duplicates are not eliminated. The low-level reason is that relational algebra is based on sets while SQL is based on multi-sets.
\subsection{Cross-product Operator}
The \textbf{Cross-product, a.k.a the Cartesian product} operator combines two relations. The schema of the new relation is the combination of the schemata of the two old relations. If they share the same attribute name, the attribute will be prefixed with the relation name. The number of tuples in the new relation will be the product of the numbers of tuples in the two relations. For example, the cross-product of \texttt{Student} and \texttt{Apply} will have 8 attributes, including \texttt{Student.sID} and \texttt{Apply.sID}. If there are \texttt{s} tuples in \texttt{Student} and \texttt{a} tuples in \texttt{Apply}, there will be \texttt{sa} tuples in \texttt{Student$\times$Apply}.

Cross-product seems not that interesting, but it is useful when combined with other operators. For example:
\begin{itemize}
\item Names and GPAs of students with HS$>$1000 who applied to CS and were rejected:
\begin{equation*}
\mathtt{\Pi_{sName,GPA}\left(\sigma_{
\begin{aligned}
&\mathtt{\scriptstyle Student.sID=Apply.sID\:\land\: sizeHS>1000}\\
&\mathtt{\scriptstyle\:\land\: major='CS'\:\land\: decision='rejected'}
\end{aligned}
}\left(Student\times Apply\right)\right)}
\end{equation*}
\end{itemize}
\subsection{Natural Join Operator}
The \textbf{Natural Join} operator performs a cross-product, enforces select for equality on all attributes with the same name, and eliminates one copy of duplicate attributes. By convention it is written as $\bowtie$ (pronounced as ``bowtie''). We use the same example to illustrate its use:
\begin{itemize}
\item Names and GPAs of students with HS$>$1000 who applied to CS and were rejected:
\begin{equation*}
\mathtt{\Pi_{sName,GPA}\left(\sigma_{sizeHS>1000\:\land\:major='CS'\:\land\:decision='rejected'}\left(Student\bowtie Apply\right)\right)}
\end{equation*}
\end{itemize}
Obviously the expression is more elegant and compact. Consider a more complicated example:
\begin{itemize}
\item Names and GPAs of students with HS$>$1000 who applied to CS at college with enrollment$>$20000 and were rejected:
\begin{equation*}
\mathtt{\Pi_{sName,GPA}\left(\sigma_{
\begin{aligned}
&\mathtt{\scriptstyle enrollment>20000\:\land\:sizeHS>1000}\\
&\mathtt{\scriptstyle\land\:major='CS'\:\land\:decision='rejected'}
\end{aligned}
}\left(Student\bowtie Apply\bowtie College\right)\right)}
\end{equation*}
\end{itemize}
Actually all we have to do is to add the \texttt{College} relation in the natural join, and add a select condition for the enrollment.

Note that natural join does not add any expressive power to relational algebra. It can always be substituted with a project composed with a select imposed on the cross-product.
\subsection{Theta Join Operator}
The \textbf{Theta Join} operator is equivalent to applying a select on the result of a cross-product. It's written as $\bowtie_{\theta}$, in which $\theta$ is the condition for the select. From the definition we have 
\begin{equation*}
\mathtt{Exp_1\bowtie_{\theta}Exp_2 = \sigma_{\theta}(Exp_1\times Exp_2)}
\end{equation*}
Like neutral join, theta join does not add any extra expressive power to relational algebra, but rather facilitates the notation. It is implemented as a basic operation in most DBMSs. In the terminology of DB management, the term ``join'' usually means theta join. 
\subsection{Union Operator}
Union does the standard set union in set theory. It is also written as $\cup$, the standard union operator in set theory. For example:
\begin{itemize}
\item List of college and student names:
\begin{equation*}
\mathtt{\Pi_{cName}College\cup\Pi_{sName}Student}
\end{equation*}
\end{itemize}
Note that this result cannot be obtained from combination of previous operators: college names and student names are listed in one column rather than two different columns. The two expressions on the two sides of the union operator ought to have the same schema, which is not the case here. This will be clarified later.  
\subsection{Difference Operator}
The \textbf{Difference} operator is written as the minus sign -. As an example:
\begin{itemize}
\item IDs of students who didn't apply anywhere:
\begin{equation*}
\mathtt{\Pi_{sID}Student-\Pi_{sID}Apply}
\end{equation*}
\item IDs and names of students who didn't apply anywhere:
\begin{equation*}
\mathtt{\Pi_{sID,sName}\left(\left(\Pi_{sID}Student-\Pi_{sID}Apply\right)\bowtie Student\right)}
\end{equation*}
\end{itemize}
Note the use of natural join in the second example. This trick is called \textbf{join back}.
\subsection{Intersection Operator}
The \textbf{Intersection} operator is written as $\cap$. For example:
\begin{itemize}
\item Names that are both a college name and a student name:
\begin{equation*}
\mathtt{\Pi_{cName}College\cap\Pi_{sName}Student}
\end{equation*}
\end{itemize}
We face the same problem of schema contradiction as with union operator. Also note that intersection operator does not add expressive power. Actually we have $\mathtt{E_1\cap E_2 \equiv E_1-(E_1-E_2)}$. From another perspective, since two expressions between which the intersection operator is used must have the same schema, we actually have $\mathtt{E_1\cap E_2\equiv E_1\bowtie E_2}$ in this case.
\subsection{Rename Operator}
The \textbf{Rename} operator is written as $\mathtt{\rho_{R(A_1,\dots,A_n)}(E)}$, which means assign the schema $\mathtt{R(A_1,\dots,A_n)}$ to the result of \texttt{E}. If only the relation name is to be changed, it can be abbreviated as $\mathtt{\rho_R(E)}$. Similarly, if only the attribute names will be changed, it can be written as $\mathtt{\rho_{A_1,\dots,A_n}(E)}$. For the second abbreviation there has to be a list of attributes, otherwise it cannot be distinguished from the first abbreviation.

Rename operator can be used to unify schemata for the set operators (union, difference and intersection). For example:
\begin{itemize}
\item List of college and student names:
\begin{equation*}
\mathtt{\rho_{C(name)}\left(\Pi_{cName}College\right)\cup\rho_{C(name)}\left(\Pi_{sName}Student\right)}
\end{equation*}
\end{itemize}
It can also be used for disambiguation in ``self-joins''. For example:
\begin{itemize}
\item Pairs of colleges in the same state:
\begin{equation*}
\mathtt{\Pi_{n1,n2}\left(\sigma_{s1=s2\:\land\:n1<n2}\left(\rho_{C1(n1,s1,e1)}(College)\times\rho_{C2(n2,s2,e2)}(College)\right)\right)}
\end{equation*}
\end{itemize}
A simpler solution to this problem is:
\begin{equation}\label{pairsamestate}
\mathtt{\Pi_{n1,n2}\left(\sigma_{n1<n2}\left(\rho_{C1(n1,s,e1)}(College)\bowtie\rho_{C2(n2,s,e2)}(College)\right)\right)}
\end{equation} 
Note that $n1<n2$ is to avoid repetitions of the same pair. $n1\neq n2$ is enough to avoid self-pair, but the same pair will appear twice in reverse order.
\subsection{Alternative Notations}
\subsubsection{Assignment Statements}
Assignment Statements can help modularize expressions. The expression \eqref{pairsamestate} can be rewritten as 
\begin{align*}
&\mathtt{C1\coloneqq\rho_{n1,s,e1}(College)}\\
&\mathtt{C2\coloneqq\rho_{n2,s,e2}(College)}\\
&\mathtt{CP\coloneqq C1\bowtie C2}\\
&\mathtt{Ans\coloneqq \Pi_{n1,n2}(\sigma_{n1<n2}CP)}
\end{align*}
\subsubsection{Expression Trees}
Expression trees help visualize the structure of an expression. Suppose we want to get the GPA of students applying to CS in CA, we can write the expression:
\begin{equation*}
\mathtt{\Pi_{GPA}(\sigma_{major='CS'\:\land\:state='CA'}(Student\bowtie College\bowtie College))}
\end{equation*}
This can be written as a tree with the three relations as leaves, the $\sigma$ as their root and the $\Pi$ as the root of the $\sigma$.

As a summary, relational algebra is a formal language that serves as the foundation of all implemented relational DBMSs. Core operators in relational algebra include relation, select, project, cross product, union, difference and rename. Other operators are useful abbreviations that do not add expressive power: natural join, theta join and intersection. 
\section{SQL}
\textbf{SQL query language}, based on relational algebra, is supported by all major commercial database systems. It's a standardized language that has been evolving over time with a lot of new features incorporated, while the essence of the language is still relatively simple. It can be used either interactively via GUI or prompt, and it can also be embedded in programs. SQL is a declarative language, which means that user has to describe only what data is needed, not how to get it. The declarative nature of SQL makes the component named \textbf{query optimizer} extremely important. SQL includes two parts:
\begin{description}
\item[Data Definition Language(DML)] \texttt{create table, drop table, etc.}
\item[Data Manipulation Language(DDL)]\texttt{select, insert, delete, update, etc.}
\end{description}
\subsection{\texttt{select} Statement}
The basic \texttt{select} statement has the form
\begin{lstlisting}
select A1,A2,...,An
from R1,R2,...,Rm
where condition
\end{lstlisting}
The \texttt{from} clause specifies the relations to query from, the \texttt{where} clause is used to combine and query the relations, and the \texttt{select} clause sets what to return. It is actually equivalent to the relational algebra expression
\begin{equation*}
\mathtt{\Pi_{A1,\dots,An}\sigma_{condition}(R1\times R2\times Rm)}
\end{equation*}
The result of a select statement is a relation whose schema is defined by the \texttt{select} clause. 

The attributes used in the condition does not necessarily appear in the result.
\begin{lstlisting}
select sID, sName from Student where GPA>3.6;
\end{lstlisting}
What is done by the natural join operator in relational algebra has to be specified explicitly in SQL.
\begin{lstlisting}
select sName, major 
from Student, Apply 
where Student.sID = Apply.sID;
\end{lstlisting}
If a few relations share the same attribute, the attribute to which it belong has to be specified to avoid ambiguous error.
\begin{lstlisting}
select College.cName --error without College
from College, Apply 
where College.cName = Apply.cName and enrollment>20000 and major = 'CS';
\end{lstlisting}
\subsubsection{\texttt{distinct} keyword}
SQL selection result contains duplicate values since it is based on a multi-set model, different from relational algebra which is based on a set model. Nonetheless, duplicate values can be avoided by adding the \texttt{distinct} keyword.
\begin{lstlisting}
select distinct sName, major 
from Student, Apply 
where Student.sID = Apply.sID;
\end{lstlisting}
\subsubsection{\texttt{order by} clause}
SQL is an unordered model. The same select statement can result in values in different orders when run multiple times. If the result values are supposed to be ordered according to a certain attribute, an \texttt{order by} clause needs to be added. The default behavior is to order in ascending order. If descending order is expected, it needs to be specified explicitly at the end of the clause. If further ordering according to other attributes is expected for rows that have the same value for the attribute specified, they should be listed afterwards in the clause. 
\begin{lstlisting}
select Student.sID, sName, GPA, Apply.cName, enrollment
From Student, College, Apply
where Student.sID = Apply.sID and College.cName = Apply.cName
order by GPA desc, enrollment;
\end{lstlisting}
\subsubsection{\texttt{like} keyword}
The \texttt{like} predicate can be used to do string pattern matching for attributes in the \texttt{where} clause.
\begin{lstlisting}
select sID, major 
from Apply
where major like '%bio%';
\end{lstlisting} 
\subsubsection{\texttt{select *}}
If all attributes in the relations are needed, instead of listing them explicitly, we can use \texttt{select *} that represents selecting all attributes.
\begin{lstlisting}
select * 
from Apply
where major like '%bio%';
\end{lstlisting} 
\subsubsection{\texttt{as} keyword}Arithmetics can be used in SQL clauses. Attribute names can be changed by the \texttt{as} keyword.
\begin{lstlisting}
select sID, sName, GPA, GPA*(sizeHS/1000.0) as scaledGPA
from Student;
\end{lstlisting}
\subsubsection{Table Variables}
Relations used in a select statement can be given another name using table variables. 
\begin{lstlisting}
select S.sID, sName, GPA, A.cName, enrollment
from Student S, Apply A, College C
where A.sID = S.sID and C.cName = S.cName;
\end{lstlisting}
Table variables are especially useful when the same relation is used multiple times in the statement. The following statement selects all pairs of students with the same GPA. 
\begin{lstlisting}
select S1.sID, S1.sName, S1.GPA, S2.sID, S2.sName, S2.GPA
from Student S1, Student S2
where S1.GPA = S2.GPA and S1.sID < S2.sID;
\end{lstlisting}
\subsubsection{Set Operators: \texttt{union, intercept} and \texttt{except}}
We can use the union operator to get the union of student names and college names.
\begin{lstlisting}
select sName as name from Student
union all
select cName as name from College
order by name;
\end{lstlisting}
SQL allows the \texttt{union} even without the \texttt{as name}. It will just use \texttt{sName} or \texttt{cName} as the attribute name in the result. The \texttt{all} keyword tells SQL to preserve all duplicate values in the result. By default duplicates are eliminated in the result of \texttt{union}. The \texttt{order by} clause sorts the result as before.

We can use \texttt{intercept} to select students who applied both CS and EE.
\begin{lstlisting}[escapeinside={@}{@}]
select sID from Apply where major = 'CS'
@\color{blue!70}intercept@
select sID from Apply where major = 'EE';
\end{lstlisting}
Some database systems do not support \texttt{intercept}. They don't lose any expressive power because the expression below is equivalent to using \texttt{intercept}:
\begin{lstlisting}
select distinct A1.sID
from Apply A1, Apply A2
where A1.sID = A2.sID and A1.major = 'CS' and A2.major = 'EE';
\end{lstlisting}

However this does not go for \texttt{except}. The following expression
\begin{lstlisting}
select sID from Apply where major = 'CS'
except
select sID from Apply where major = 'EE';
\end{lstlisting}
cannot be expressed by the constructs we have introduced up to now. Additional constructs are needed not to lose this expressive power.
\subsection{Subqueries in Clauses}
Subqueries are \texttt{select} statements nested inside clauses of another \texttt{select} statement. The following statement select IDs and names of all students who apply for CS.
\begin{lstlisting}
select sID, sName
from Student
where sID in (select sID from Apply where major = 'CS');
\end{lstlisting}
This is actually equivalent to 
\begin{lstlisting}
select distinct Student.sID, sName
from Student, Apply
where Student.sID = Apply.sID and major = 'CS';
\end{lstlisting}
\subsubsection{Extra Expressive Power}
However, \texttt{distinct} does not always brings such an equivalent. Consider
\begin{lstlisting}
select GPA
from Student
where sID in (select sID from Apply where major = 'CS');
\end{lstlisting}
The version without sub-queries
\begin{lstlisting}
select GPA
from Student, Apply
where Student.sID = Apply.sID and major = 'CS';
\end{lstlisting}
cannot provide the same result, with or without \texttt{distinct}. The reason is that two kinds of duplicates are involved in this examples:
\begin{itemize}
\item GPA of the same student applying for CS multiple times at different colleges.
\item Different students applying for CS who have the same GPA.
\end{itemize}
The statement using a sub-query preserves the second kind and eliminates the first one, which is plausible for calculating the average GPA of students who apply for CS. However, the version without sub-query either preserves both kinds (without \texttt{distinct}), or eliminates both(with \texttt{distinct}). This example proves that sub-query does add expressive power to SQL.

Besides facilitating the processing of duplicates, sub-queries also makes it possible to express \texttt{except} without using it. The example of \texttt{except} in the previous section is equivalent to
\begin{lstlisting}
select sID 
from Student
where sID in (select sID from Apply where major = 'CS')
  and sID not in (select sID from Apply where major = 'EE');
\end{lstlisting}
Note that \texttt{sID not in ...} is equivalent to \texttt{not sID in ...}.
\subsubsection{\texttt{exists} keyword}
\begin{lstlisting}
--Colleges such that some other college is in the same state
select cName, state
from College C1
where exists (select * from College C2 
              where C2.state = C1.state and C2.cName <> C1.cName);
--College with the largest enrollment
select cName
from College C1
where not exists (select * from College C2
	              where C2.enrollment > C1.enrollment);
\end{lstlisting}
\subsubsection{\texttt{all} keyword}
\begin{lstlisting}
--students with highest GPA
select sName, GPA
from Student
where GPA >= all (select GPA from Student);
\end{lstlisting}
\subsubsection{\texttt{any} keyword}
\begin{lstlisting}
--students not coming from the smallest high school
select sID, sName, sizeHS
from Student
where sizeHS > any (select sizeHS from Student);
\end{lstlisting}
Some database systems do not support \texttt{any} and \texttt{all}. They do not lose expressive power.
\ifx\PREAMBLE\undefined
\end{document}
\fi