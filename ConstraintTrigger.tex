\ifx\PREAMBLE\undefined
\input{preamble}
\begin{document}
\fi
\chapter{Constraints and Triggers}
Constraints, or integrity constraints constrain the allowable states of the database, while triggers monitor database changes, check conditions and possibly initiates actions on being activated. 
\section{Overview}
\subsection{Constraints}
\textbf{Integrity constraints} impose restrictions on allowable data beyond those imposed by the structure of the DB and types of the attributes. For example, in our \texttt{Student} table, the \texttt{GPA} value is required to fall inside (0.0, 4.0]; in the \texttt{Apply} table and the value of \texttt{decision} should be either \texttt{Y}, \texttt{N} or \texttt{Null}. Constraints can be logically more complicated, e.g. the condition that no decisions have been made for CS applicants can be expressed as the constraint \texttt{major = `CS' $\Rightarrow$ decision = Null}. 

Constrains are enforced for several purposes:
\begin{itemize}
\item To automatically catch data-entry error when doing insertions. 
\item As correctness criteria when doing updates. 
\item To enforce consistency.
\item To inform the system of properties of the data so as to facilitate better storage and queries.
\end{itemize}

Constraints are classified into:
\begin{itemize}
\item Non-null constraints. An attribute can be forbidden from having null value.
\item Key constraints. Attributes specified as key should have unique value combinations. 
\item Referential integrity (foreign key).
\item Attribute-based constraints.
\item Tuple-based constraints.
\item General assertions.
\end{itemize}

Constraints can be declared either when the schema is created or later. In the former case, it is checked after bulk loading, while in the latter case it is checked on the state of the DB at the time of the declaration. 

Normally a constraint should be checked after every modification that may cause a violation to it. Constraint checking can also be carried out only after each transaction, which is called deferred constraint checking: constraints are allowed to be violated during the transaction, but if any violation still exists after the transaction is completed, the whole transaction gets rolled back. 
\subsection{Trigger}
\textbf{Trigger} is a more dynamic concept than constraints. Constraints put restrictions on each state of the DB, while triggers limit how the DB evolves. Triggers are also called ``Event-Condition-Action Rules'' because they usually have the form 
\begin{center}
When \emph{event} occurs, check \emph{condition}; If true, do \emph{action}. 
\end{center}
For example, a trigger can be set up to accept applications from student with a GPA  higher than 3.95 automatically:
\texttt{insert application with GPA$>$3.95 $\Rightarrow$ accept}.

Triggers are enforced for the following purposes:
\begin{itemize}
\item To move logic from application into DBMS.
\item To enforce constraints. In mainstream implementations, the trigger feature is more expressive than the constraint feature. Moreover, triggers make it possible to repair the DB when a constraint violation is found.
\end{itemize}
\section{SQL for Constraints}
\subsection{Non-null Constraints}
To add a non-null constraint to an attribute when creating the table, we need to add the keyword \texttt{not null} to the attribute. 
\begin{lstlisting}
create table Student(sID int, sName text, GPA real not null, sizeHS int);
\end{lstlisting}
\subsection{Key Constraints}
A key constraint requires that values of the specified attribute be unique.
\begin{lstlisting}
create table Student(sID int primary key, sName text, GPA real, sizeHS int);
\end{lstlisting}
Suppose the table contains two tuples:
\begin{lstlisting}
234 Bob 3.6 1500
123 Amy 3.9 1000
\end{lstlisting}
The statement
\begin{lstlisting}
update Student set sID = sID - 111;
\end{lstlisting}
is possible to cause an error because Bob will have the same sID as Amy if it gets updated first. This demonstrates the situation in which deferred constraint checking should be used.

There can be only one primary key in each table. If attributes other than the primary key is supposed to be unique, the keyword \texttt{unique} should be used.
\begin{lstlisting}
create table Student(sID int primary key, sName text unique, GPA real, sizeHS int);
\end{lstlisting}
The following examples demonstrate the case in which a combination of attributes is used as the primary key.
\begin{lstlisting}
create table College(cName text, state text, enrollment int, primary key (cName,state));
create table Apply(sID int, cName text, major text, decision text, primary(sID, cName), unique(sID, major));
\end{lstlisting}
Note that Null values are handled specially. SQL standard and most implementations allow repeated Null values even if the column is declared as unique. However repeated Null values are usually not permitted for the primary key.
\subsection{Attribute/Tuple Based Constraints}
Attribute-based constraints are often used to catch data entry errors concerning ranges of attributes. They are check whenever a tuple is inserted or updated. In the following example we put limits to the range of GPA and sizeHS. 
\begin{lstlisting}
create table Student(
	sID int, sName text,
	GPA read check(GPA <= 4.0 and GPA > 0.0),
	sizeHS int check(sizeHS < 5000));
\end{lstlisting}
Tuple-Based constraints also catches data entry errors, but it puts limits to relationship of different attributes inside a tuple. In the following example, the tuple-based constraint rules out successful applications for CS major of Stanford.  
\begin{lstlisting}
create table Apply(sID int, cName text, major text, decision text,
	check(decision = 'N' or cName <> 'Standord' or major <> 'CS'));
\end{lstlisting}
Attribute/Tuple based constraints may be syntactically allowed but not enforced in MySQL. Currently sub-queries are allowed in check constraints in no implementation, although they are listed in SQL standard and might be syntactically permitted in certain implementations.  
\subsection{General Assertion}
General assertions are very powerful, but unfortunately not supported in any mainstream DBMS. In the SQL standard it takes the form
\begin{lstlisting}
--A is unique
create assertion Key
check ((select count(distinct A) from T) =
       (select count(*) from T));
--Apply only contains sID from Student
create assertion ReferentialIntegrity
check (not exists (select * from Apply
	where sID not in (select sID from Student)));
--Average GPA of admitted students higher than 3.0
create assertion AvgAccept
check (3.0 < (select avg(GPA) from Student 
	where sID in (select sID from Apply 
		where decision = 'Y')));
\end{lstlisting}
The complexity of implementing general assertion comes from the requirement that it has to be checked each time any modification that can possibly cause violation is made to the DB.
\subsection{Referential Integrity}
Referential integrity handles the integrity of references in a database. No ``dangling pointer'' is allowed. In our example, it should be guaranteed that an \texttt{sID} in \texttt{Apply} refers to a student in \texttt{Student}, and that a \texttt{cName} in \texttt{Apply} refers to a college in \texttt{College}, i.e. we have referential integrities \texttt{Apply.sID to Student.sID} and \texttt{Apply.cName to College.cName}, as shown below. Note that referential integrity is a directional constraint. 
\begin{lstlisting}
create table Student(sID int primary key, sName text, GPA real, sizeHS int);
create table College(cName text primary key, state text, enrollment int);
create table Apply(sID int references Student(sID), 
				cName text references College(cName),
				major text, decision text);
\end{lstlisting}

In a referential integrity \texttt{R.A to S.B}, \texttt{A} is called the \textbf{foreign key}. \texttt{B} is usually required to be the primary key of \texttt{S}, or at least a \texttt{unique} attribute. Multi-attribute foreign key is allowed. 

The enforcement of referential integrity \texttt{R.A to S.B} should consider possible violations by the following operations: 
\begin{itemize}
\item insert into \texttt{R};
\item delete from \texttt{S};
\item update \texttt{R.A};
\item update \texttt{S.B}.
\end{itemize}
For insertion to \texttt{R} and update of \texttt{R.A}(the referencing table), the referential integrity is simply checked. The referential integrity also prevents us from dropping table \texttt{S}. For deletion from \texttt{S}, three types of actions are possible:
\begin{description}
\item[Restrict(default)]Generate an error.
\item[Set Null]Set referencing tuples in \texttt{R} to have Null value for \texttt{R.A}.
\item[Cascade]Delete all referencing tuples in \texttt{R}. 
\end{description}
Actions for update of \texttt{S.B}(the referenced table) are similar, except that for cascade, the same update is propagated to \texttt{R.A} in \texttt{R}. The actions can be set in the form
\begin{lstlisting}
create table Apply(sID int references Student(sID) on delete set null, 
				cName text references College(cName) on update cascade,
				major text, decision text);
\end{lstlisting}
We can have referential integrities within the same table:
\begin{lstlisting}
create table T(A int, B int, C int, D int, primary key(A,B), 
	foreign key (B,C) references T(A,B) on delete cascade);
\end{lstlisting}
\section{SQL for Triggers}
\ifx\PREAMBLE\undefined
\end{document}
\fi